# -*- coding: utf-8 -*-
"""Improved Streamlit Prophet Forecasting App

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1RanRXl18o1dK6zEHqdkdrIC9-34AwB-c
"""

import streamlit as st
import pandas as pd
import numpy as np
from prophet import Prophet
from prophet.plot import plot_plotly, plot_components_plotly # For interactive Plotly charts
from sklearn.metrics import mean_squared_error, mean_absolute_error, r2_score
from math import sqrt
import plotly.graph_objs as go # Useful for custom Plotly elements if needed, but Prophet's wrappers are often sufficient

# --- Custom MAPE function ---
def mean_absolute_percentage_error(y_true, y_pred):
    """
    Calculates the Mean Absolute Percentage Error (MAPE).
    Handles potential division by zero for y_true values.
    Args:
        y_true (np.ndarray): True values.
        y_pred (np.ndarray): Predicted values.
    Returns:
        float: The MAPE value.
    """
    y_true, y_pred = np.array(y_true), np.array(y_pred)
    # Filter out actual values that are zero to avoid division by zero
    non_zero_mask = y_true != 0
    if not np.any(non_zero_mask):
        return 0.0 # Return 0 if all true values are zero

    return np.mean(np.abs((y_true[non_zero_mask] - y_pred[non_zero_mask]) / y_true[non_zero_mask])) * 100

# --- Streamlit App Configuration ---
st.set_page_config(page_title="Exchange Rate Forecast", layout="wide") # Use wide layout for better plot display
st.title("ðŸ“ˆ Prophet Forecast with Macroeconomic Regressors")

st.markdown("""
This application allows you to forecast a selected target macroeconomic variable
using the Prophet model, incorporating other columns in the dataset as regressors.
""")

# --- Data Loading ---
st.header("1. Load Your Data")
uploaded_file = st.file_uploader("Upload your data file (CSV format expected)", type="csv")

df_raw = None
if uploaded_file is not None:
    try:
        df_raw = pd.read_csv(uploaded_file, parse_dates=['Date'], index_col='Date')
        st.success("Data loaded successfully!")
        st.dataframe(df_raw.head())
    except Exception as e:
        st.error(f"Error loading file: {e}. Please ensure it's a valid CSV with a 'Date' column.")
else:
    st.info("No file uploaded. Using a sample dataset for demonstration.")
    # Attempt to load from a fixed path for local development/Streamlit Cloud if file exists
    try:
        # Assuming 'dfmonthly_modelling.csv' is in the repo for Streamlit Cloud
        df_raw = pd.read_csv('dfmonthly_modelling.csv', parse_dates=['Date'], index_col='Date')
        st.dataframe(df_raw.head())
    except FileNotFoundError:
        st.warning("`dfmonthly_modelling.csv` not found in the repository. Generating a dummy dataset for demonstration.")
        # Create a dummy dataframe for local testing if the actual file isn't present
        dates = pd.date_range(start='2005-01-01', periods=228, freq='MS')
        data = {
            'exchange_rate': np.linspace(70, 150, 228) + np.random.normal(0, 5, 228).cumsum(),
            '12-month_inflation%': np.linspace(5, 10, 228) + np.random.normal(0, 1, 228),
            'central_bank_rate': np.linspace(6, 12, 228) + np.random.normal(0, 0.5, 228),
            'total_remittances': np.linspace(50000, 300000, 228) + np.random.normal(0, 10000, 228),
            'imports': np.linspace(1e10, 2e10, 228) + np.random.normal(0, 1e9, 228),
            'exports': np.linspace(5e9, 1.2e10, 228) + np.random.normal(0, 5e8, 228),
            'total_debt': np.linspace(1e6, 8e6, 228) + np.random.normal(0, 5e5, 228),
            'deposit': np.linspace(5, 10, 228) + np.random.normal(0, 0.3, 228),
            'savings': np.linspace(3, 8, 228) + np.random.normal(0, 0.2, 228),
            'lending': np.linspace(10, 15, 228) + np.random.normal(0, 0.8, 228),
            'overdraft': np.linspace(12, 18, 228) + np.random.normal(0, 1.0, 228),
        }
        df_raw = pd.DataFrame(data, index=dates)
        st.dataframe(df_raw.head())
        st.warning("Note: Using dummy data. For real results, please upload your `dfmonthly_modelling.csv`.")


if df_raw is not None:
    # Ensure index is datetime and sorted
    df_raw.index = pd.to_datetime(df_raw.index)
    df_raw = df_raw.sort_index()

    # Fill NaN values in numerical columns using median
    for col in df_raw.select_dtypes(include=np.number).columns:
        if df_raw[col].isnull().any():
            df_raw[col] = df_raw[col].fillna(df_raw[col].median())

    # --- Sidebar for User Inputs ---
    st.sidebar.header("Model Configuration")

    # Select target column
    available_cols = df_raw.columns.tolist()
    # Attempt to pre-select 'exchange_rate' if it exists, otherwise select the first column
    default_target_index = available_cols.index('exchange_rate') if 'exchange_rate' in available_cols else 0
    target_column = st.sidebar.selectbox(
        "Select Target Variable (y):",
        options=available_cols,
        index=default_target_index
    )

    # Slider for prediction months
    num_future_months = st.sidebar.slider(
        "Number of Months to Forecast:",
        min_value=0, # Allow 0 for just evaluation on historical data
        max_value=24,
        value=12,
        step=1
    )

    # --- Prepare DataFrame for Prophet ---
    # Prophet requires 'ds' for date and 'y' for target
    df_prophet = df_raw.reset_index().rename(columns={'Date': 'ds', target_column: 'y'})

    # Identify regressor columns (all other numerical columns excluding 'ds' and 'y')
    regressor_cols = [col for col in df_prophet.columns if col not in ['ds', 'y'] and pd.api.types.is_numeric_dtype(df_prophet[col])]

    st.header("2. Model Setup & Forecast")
    st.info(f"**Target Variable:** `{target_column}`")
    st.info(f"**Number of Forecast Months:** `{num_future_months}`")
    if regressor_cols:
        st.info(f"**Regressors Used:** `{', '.join(regressor_cols)}`")
    else:
        st.warning("No regressors detected/selected. Model will be fitted without extra regressors.")

    # --- Prophet Model Initialization and Fitting ---
    if st.button("Generate Forecast & Metrics"):
        if len(df_prophet) < 2:
            st.error("Not enough data points to train the Prophet model. Minimum 2 points required.")
        else:
            with st.spinner("Training Prophet model and generating forecast..."):
                model = Prophet()

                # Add each regressor to the model
                for col in regressor_cols:
                    model.add_regressor(col)

                try:
                    # Fit the model
                    model.fit(df_prophet)

                    # Create future dataframe for prediction
                    future = model.make_future_dataframe(periods=num_future_months, freq='MS')

                    # Populate future regressor values with the last known value (most recent historical value)
                    # This is a common, simple approach for demo purposes.
                    # In a production scenario, these future regressor values would typically be forecasted themselves.
                    for col in regressor_cols:
                        if col in df_prophet.columns: # Ensure regressor column exists
                            # For dates present in df_prophet, use actual values
                            past_mask = future['ds'].isin(df_prophet['ds'])
                            future.loc[past_mask, col] = df_prophet.set_index('ds').loc[future.loc[past_mask, 'ds'], col].values
                            # For future dates, fill with the last known value
                            future[col].fillna(df_prophet[col].iloc[-1], inplace=True)
                        else:
                            st.warning(f"Regressor column '{col}' not found in prepared data. Skipping.")
                            # You might want to handle this more robustly, e.g., drop the regressor from `regressor_cols`

                    # Make predictions
                    forecast = model.predict(future)

                    st.success("Forecast generated!")

                    # --- Display Forecast Plot (using Plotly for interactivity) ---
                    st.subheader("3. Forecast Plot")
                    fig1_plotly = plot_plotly(model, forecast)
                    fig1_plotly.update_layout(
                        title=f"Prophet Forecast of {target_column}",
                        xaxis_title="Date",
                        yaxis_title=target_column,
                        hovermode="x unified",
                        height=500
                    )
                    st.plotly_chart(fig1_plotly, use_container_width=True)

                    # --- Display Components Plot (using Plotly for interactivity) ---
                    st.subheader("4. Forecast Components")
                    fig2_plotly = model.plot_components(forecast)
                    fig2_plotly.update_layout(
                        title=f"Components of {target_column} Forecast",
                        hovermode="x unified",
                        height=800 # Adjust height as components plot can be tall
                    )
                    st.plotly_chart(fig2_plotly, use_container_width=True)

                    # --- Display Evaluation Metrics ---
                    st.subheader("5. Model Evaluation on Training Data")

                    forecast_train = model.predict(df_prophet)
                    y_true = df_prophet['y'].values
                    y_pred = forecast_train['yhat'].values

                    rmse = sqrt(mean_squared_error(y_true, y_pred))
                    mae = mean_absolute_error(y_true, y_pred)
                    mse = mean_squared_error(y_true, y_pred)
                    mape = mean_absolute_percentage_error(y_true, y_pred)
                    r2 = r2_score(y_true, y_pred)

                    metrics_df = pd.DataFrame({
                        "Metric": ["RMSE", "MAE", "MSE", "MAPE", "R-squared"],
                        "Value": [f"{rmse:.4f}", f"{mae:.4f}", f"{mse:.4f}", f"{mape:.2f}%", f"{r2:.4f}"]
                    })
                    st.table(metrics_df)

                    st.markdown("""
                    * **RMSE (Root Mean Squared Error):** Measures the average magnitude of the errors. Lower is better.
                    * **MAE (Mean Absolute Error):** Measures the average absolute difference between predictions and actual values. Lower is better.
                    * **MSE (Mean Squared Error):** Measures the average of the squares of the errors. Lower is better.
                    * **MAPE (Mean Absolute Percentage Error):** The average percentage error. Lower is better.
                    * **R-squared (RÂ²):** Represents the proportion of the variance in the dependent variable that is predictable from the independent variables. Closer to 1 is better.
                    """)

                    st.subheader("6. Future Forecast Data Table")
                    # Display only the forecast part of the table
                    st.dataframe(forecast[['ds', 'yhat', 'yhat_lower', 'yhat_upper']].tail(num_future_months))
                    st.info(f"Showing forecast for the next {num_future_months} months.")

                except Exception as e:
                    st.error(f"An error occurred during model fitting or prediction: {e}")
                    st.info("Please check your data and ensure it's suitable for Prophet (e.g., sufficient historical data, no non-numeric values in regressor columns after preprocessing).")

else:
    st.warning("Please upload a CSV file or ensure `dfmonthly_modelling.csv` is in the repository to proceed with the forecasting.")